<!DOCTYPE html>
<html>
	<head>
		<link type="text/css" rel="stylesheet" href="./css/main.css">
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Personal Website</title>
	</head>
	<body>
		<section id="main">
			<!--navigation-------------------------------->
			<nav>
			<div class="toggle"></div>
			<ul class="menu">
			<li class="active"><a href="#main" >Home</a></li>	
			<li><a href="about.html">About</a></li>	
			<li><a href="benji.html">Benji</a></li>	
			<li><a href="contact.html">Contact</a></li>
			</ul>
			</nav>
		</section>
		<div id="target_div" class="circle bottom-center">
		</div>
		<div id="projection" class="front-center">
		</div>
		
		<script type="x-shader/x-vertex" id="vertexshader">
       		uniform float scale;
			void main() {
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = scale * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

    	<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			void main() {
			  gl_FragColor = vec4(color, 1.0);
			}
		</script>

		<script type="module">
  			import * as THREE from 'https://cdn.skypack.dev/three@0.134.0';
			import { OrbitControls } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/controls/OrbitControls.js';
			import { CSS3DRenderer, CSS3DObject } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/renderers/CSS3DRenderer.js';
			var mouseX = 0, mouseY = 0;
		    var camera, controls, gl_scene, css_scene, gl_renderer, css_renderer;
		    var windowHalfX = window.innerWidth / 2 ;
			var windowHalfY = window.innerHeight / 2;
			var mouse_projection;
			var label;

			init();
            animate();

			function init() {
				gl_renderer = new THREE.WebGLRenderer( { antialias: true } );
				gl_renderer.setSize( window.innerWidth, window.innerHeight );
				// renderer.domElement.style.position = 'absolute';
				// renderer.domElement.style.zIndex = 1;
				// renderer.domElement.style.top = 0;
				css_renderer = new CSS3DRenderer();
				css_renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( gl_renderer.domElement );
				gl_renderer.domElement.appendChild( css_renderer.domElement );

				// Create the scene.
				gl_scene = new THREE.Scene();
				gl_scene.background = new THREE.Color( 0xF4F7FF );
				css_scene = new THREE.Scene();

				// Create the orbiting camera.
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				controls = new OrbitControls( camera, gl_renderer.domElement );
				camera.position.set( 0,2,3 );
				controls.update();
				controls.addEventListener( 'change', render );
				controls.autoRotate = true;

				// Create the Riemann Sphere.
				var material = new THREE.ShaderMaterial( {
					uniforms: {
						color: { value: new THREE.Color( 0x7743F8 ) },
						scale: { value: 0.01 },
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent
				} );
				const points = [];
				for (var x = -10; x <= 10 ; x = x + .025) {
					for (var y = -10; y <= 10; y = y + .025) {
						var denom = (1 + x**2 + y**2);
						var project_x = 2*x / denom;
						var project_y = 2*y / denom;
						var project_z = (y**2 + x**2 - 1) / denom;
						points.push( new THREE.Vector3( project_x, project_y, project_z) );
					}
				}
				const geometry = new THREE.BufferGeometry().setFromPoints( points );
				const particles = new THREE.Points( geometry, material );
				particles.rotateX( -Math.PI / 2 );
				gl_scene.add( particles );

				// Create each axis.
				// TODO: Label axis.
				const axis_material = new THREE.LineBasicMaterial( { color: 0xFC404E } );
				const x_axis_points = [];
				x_axis_points.push( new THREE.Vector3( - 10, 0, 0 ) );
				x_axis_points.push( new THREE.Vector3( 0, 0, 0 ) );
				x_axis_points.push( new THREE.Vector3( 10, 0, 0 ) );
				const x_axis_geometry = new THREE.BufferGeometry().setFromPoints( x_axis_points );
				const y_axis_points = [];
				y_axis_points.push( new THREE.Vector3( 0, -10, 0 ) );
				y_axis_points.push( new THREE.Vector3( 0, 0, 0 ) );
				y_axis_points.push( new THREE.Vector3( 0, 10, 0 ) );
				const y_axis_geometry = new THREE.BufferGeometry().setFromPoints( y_axis_points );
				const z_axis_points = [];
				z_axis_points.push( new THREE.Vector3( 0, 0, -10 ) );
				z_axis_points.push( new THREE.Vector3( 0, 0, 0 ) );
				z_axis_points.push( new THREE.Vector3( 0, 0, 10 ) );
				const z_axis_geometry = new THREE.BufferGeometry().setFromPoints( z_axis_points );
				const x_axis = new THREE.Line( x_axis_geometry, axis_material );
				const y_axis = new THREE.Line( y_axis_geometry, axis_material );
				const z_axis = new THREE.Line( z_axis_geometry, axis_material );			    
				gl_scene.add( x_axis );
				gl_scene.add( y_axis );
				gl_scene.add( z_axis );

				// Create the grid.
				const grid = new THREE.GridHelper( 10, 100 );
				grid.material.opacity = 0.25;
				grid.material.transparent = true;
				gl_scene.add( grid );

				// Render the scenes.
				gl_renderer.render( gl_scene, camera );
				css_renderer.render( css_scene, camera );
				// Add listeners.
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function render() {
				// Remove previous projections.
				if (mouse_projection) {
					gl_scene.remove( mouse_projection );
				}
				if (label) {
					css_scene.remove( label );
				}

				// Calculate projection using the new mouse coordinates.
			    var denom = (1 + mouseX**2 + mouseY**2);
				var project_x = 2*mouseX / denom;
				var project_y = 2*mouseY / denom;
				var project_z = (mouseY**2 + mouseX**2 - 1) / denom;
				// Print the mouse coordinates to the info circle.
				var div = document.getElementById('target_div');
				div.innerHTML = `<p id="text">Mouse: [${mouseX.toFixed(2)}, ${mouseY.toFixed(2)}] -> Projection [${project_x.toFixed(2)}, ${project_y.toFixed(2)}, ${project_z.toFixed(2)}]</p>`;
				var div = document.getElementById('projection');
				div.innerHTML = `(${mouseX.toFixed(2)},${mouseY.toFixed(2)})`;
				var label = new CSS3DObject( div );
				label.position.x = mouseX;
				label.position.y = mouseY;
				label.position.z = 0;
				console.log(label.position.x);
				css_scene.add( label );

				const mouse_material = new THREE.LineBasicMaterial( { color: 0x000000 } );
				const mouse_points = [];
				mouse_points.push( new THREE.Vector3( 0, 0, 1 ) );
				mouse_points.push( new THREE.Vector3( project_x, project_y, project_z ) );
				const mouse_geometry = new THREE.BufferGeometry().setFromPoints( mouse_points );
				mouse_projection = new THREE.Line( mouse_geometry, mouse_material );
				mouse_projection.rotateX( - Math.PI / 2);
				gl_scene.add( mouse_projection );

				// Render the new scene.
				gl_renderer.render( gl_scene, camera );
				css_renderer.render( css_scene, camera );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				gl_renderer.setSize( window.innerWidth, window.innerHeight );
				css_renderer.setSize( window.innerWidth, window.innerHeight )
			}

			function onDocumentMouseMove( event ) {
				mouseX = (event.clientX - windowHalfX ) / (window.innerWidth / 10);
				mouseY = (event.clientY - windowHalfY) / (window.innerHeight / 10);
			}
			
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				render();
			}	
		</script>
	</body>
</html>