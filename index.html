<!DOCTYPE html>
<html>
	<head>
		<link type="text/css" rel="stylesheet" href="./css/main.css">
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<div id="target_div" class="circle left-corner name-card"></div>
		
		<script type="x-shader/x-vertex" id="vertexshader">
       		uniform float scale;
			void main() {
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = scale * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

    	<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			void main() {
			  gl_FragColor = vec4(color, 1.0);
			}
		</script>

		<script type="module">
  			import * as THREE from 'https://cdn.skypack.dev/three@0.134.0';
import { OrbitControls } from 'https://cdn.skypack.dev/three@0.134.0/examples/jsm/controls/OrbitControls.js';
			var mouseX = 0, mouseY = 0;
		    var camera, controls,scene, renderer;
		    var windowHalfX = window.innerWidth / 2 ;
			var windowHalfY = window.innerHeight / 2;
			var mouse_projection;

			init();
            animate();

			function init() {
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				controls = new OrbitControls( camera, renderer.domElement );
				camera.position.set( 0,2,3 );
				controls.update();
				controls.addEventListener( 'change', render );
				controls.autoRotate = true;

				// Create the Riemann Sphere.
				var material = new THREE.ShaderMaterial( {
					uniforms: {
						color: { value: new THREE.Color( 0x7743F8 ) },
						scale: { value: 0.01 },
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent
				} );
				const points = [];
				for (var x = -10; x <= 10 ; x = x + .025) {
					for (var y = -10; y <= 10; y = y + .025) {
						var denom = (1 + x**2 + y**2);
						var project_x = 2*x / denom;
						var project_y = 2*y / denom;
						var project_z = (y**2 + x**2 - 1) / denom;
						points.push( new THREE.Vector3( project_x, project_y, project_z) );
					}
				}
				const geometry = new THREE.BufferGeometry().setFromPoints( points );
				const particles = new THREE.Points( geometry, material );
				particles.rotateX( -Math.PI / 2 );

				// Create axises?.
				const axis_material = new THREE.LineBasicMaterial( { color: 0xFC404E } );
				const x_axis_points = [];
				x_axis_points.push( new THREE.Vector3( - 10, 0, 0 ) );
				x_axis_points.push( new THREE.Vector3( 0, 0, 0 ) );
				x_axis_points.push( new THREE.Vector3( 10, 0, 0 ) );
				const x_axis_geometry = new THREE.BufferGeometry().setFromPoints( x_axis_points );
				const y_axis_points = [];
				y_axis_points.push( new THREE.Vector3( 0, -10, 0 ) );
				y_axis_points.push( new THREE.Vector3( 0, 0, 0 ) );
				y_axis_points.push( new THREE.Vector3( 0, 10, 0 ) );
				const y_axis_geometry = new THREE.BufferGeometry().setFromPoints( y_axis_points );
				const z_axis_points = [];
				z_axis_points.push( new THREE.Vector3( 0, 0, -10 ) );
				z_axis_points.push( new THREE.Vector3( 0, 0, 0 ) );
				z_axis_points.push( new THREE.Vector3( 0, 0, 10 ) );
				const z_axis_geometry = new THREE.BufferGeometry().setFromPoints( z_axis_points );
				const x_axis = new THREE.Line( x_axis_geometry, axis_material );
				const y_axis = new THREE.Line( y_axis_geometry, axis_material );
				const z_axis = new THREE.Line( z_axis_geometry, axis_material );			    

				// Create the plane
				const grid = new THREE.GridHelper( 10, 100 );
				grid.material.opacity = 0.25;
				grid.material.transparent = true;
				//grid.rotateX( Math.PI / 2 );
				// const plane_geometry = new THREE.PlaneGeometry( 10, 100 );
				// plane_geometry.rotateZ( Math.PI / 2 );
				// const plane = new THREE.Mesh( plane_geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
				
				// Create the scene.
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xDBECEF );
				scene.add( grid );
				// scene.add( plane );
				scene.add( particles );
				scene.add( x_axis );
				scene.add( y_axis );
				scene.add( z_axis );

				// Render the scene.
				renderer.render( scene, camera );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function render() {
				if (mouse_projection) {
					scene.remove( mouse_projection );
				}
			    var denom = (1 + mouseX**2 + mouseY**2);
				var project_x = 2*mouseX / denom;
				var project_y = 2*mouseY / denom;
				var project_z = (mouseY**2 + mouseX**2 - 1) / denom;

				var div = document.getElementById('target_div');
				div.innerHTML = `Mouse: [${mouseX.toFixed(2)}, ${mouseY.toFixed(2)}] -> Project [${project_x.toFixed(2)}, ${project_y.toFixed(2)}, ${project_z.toFixed(2)}]`;
				const mouse_material = new THREE.LineBasicMaterial( { color: 0x000000 } );
				const mouse_points = [];
				mouse_points.push( new THREE.Vector3( 0, 0, 1 ) );
				mouse_points.push( new THREE.Vector3( project_x, project_y, project_z ) );
                // Maybe we should project the point on the plane.
				// mouse_points.push( new THREE.Vector3( mouseX, mouseY, 0 ) );
				const mouse_geometry = new THREE.BufferGeometry().setFromPoints( mouse_points );
				mouse_projection = new THREE.Line( mouse_geometry, mouse_material );
				mouse_projection.rotateX( - Math.PI / 2)
				scene.add( mouse_projection );
			    //camera.lookAt( mouse_points[1] );

				renderer.render( scene, camera );

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {
				console.log("Event [%o, %o]", event.clientX, event.clientY);
				mouseX = (event.clientX - windowHalfX ) / (window.innerWidth / 10);
				mouseY = (event.clientY - windowHalfY) / (window.innerHeight / 10);
			}
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				render();
			}	
		</script>
	</body>
</html>